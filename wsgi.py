#!/usr/bin/python3.11

from authlib.integrations.flask_client import OAuth
from cachelib import FileSystemCache
from datetime import timedelta
from flask import Flask, session, redirect, render_template, url_for, request
from flask_session import Session
from http import HTTPStatus, HTTPMethod
from oci.config import DEFAULT_LOCATION, DEFAULT_PROFILE
from oci.util import to_dict
from os import getenv
from secrets import token_urlsafe
from time import sleep
from werkzeug import exceptions

from modules import create_signer
from modules.search import Search
from modules.delete import Deleter

### Globals
TIMEOUT_IN_SECONDS = 900
PREFIX = 'OCIDOMAIN'
idm_host = getenv(f'{PREFIX}_IDM_ENDPOINT')
app_host = getenv(f'{PREFIX}_APP_URI')

app = Flask(__name__)
app.config['SESSION_COOKIE_NAME'] = 'omid'
app.config['SESSION_TYPE'] = 'cachelib'
# FileSystemCache is a cachelib local filesystem cache, saves sessions to ./session
app.config['SESSION_CACHELIB'] = FileSystemCache('session',
                                                 default_timeout=TIMEOUT_IN_SECONDS)
app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'
app.config['PERMANENT_SESSION_LIFETIME'] = timedelta(seconds=TIMEOUT_IN_SECONDS)
Session(app) # Using local filesystem session cache

# OCI SDK Authentication
cfg, signer = create_signer(getenv(f'{PREFIX}_AUTH_TYPE'),
                            profile=getenv(f'{PREFIX}_PROFILE', DEFAULT_PROFILE),
                            location=getenv(f'{PREFIX}_LOCATION', DEFAULT_LOCATION))

# Search
search = Search(
    getenv(f'{PREFIX}_TAG_NAMESPACE'),
    getenv(f'{PREFIX}_TAG_KEY'),
    cfg,
    signer=signer,
    log_level=app.logger.getEffectiveLevel())

# Delete
deleter = Deleter(cfg,
                 signer=signer,
                 log_level=app.logger.getEffectiveLevel())

# OIDC
oauth = OAuth(app)
oauth.register(
    'ocidomain',
    client_id=getenv(f'{PREFIX}_CLIENT_ID'),
    client_secret=getenv(f'{PREFIX}_CLIENT_SECRET'),
    server_metadata_url=f'{idm_host}/.well-known/openid-configuration',
    client_kwargs={'scope': 'openid'})

# Generate a dict of random tokens and return it
def generate_csrf_tokens(n: int) -> dict:
    tokens = {}

    for i in range(n):
        tokens[token_urlsafe()] = None

    return tokens

### Handlers

# Homepage handler
@app.route('/', methods=[HTTPMethod.GET])
def home():
    if session.get('user'):
        return render_template('index.html',
                               user=session.get('user'),
                               selection=search.resource_list)
    
    return render_template('index.html')

# Pagination support using HTMX
@app.route('/p', methods=[HTTPMethod.GET])
def pagination():
    if session.get('user'):
        
        # Check to see if resource filter has changed
        resource_type = request.args.get('resource_type')
        if resource_type:
            session['resource_type'] = resource_type

        results = search.get_user_resources(
            session.get('user'),
            page=request.args.get('next_page', None),
            resource=session['resource_type'])
        items = to_dict(results.data)['items']
        app.logger.debug(f'Items returned for user {session.get("user")}:'
                         f'\t{items}')

        # Generate CSRF tokens to attach to possible requests generated by the template
        tokens = generate_csrf_tokens(len(items))
        session['csrf_tokens'].update(tokens)
        app.logger.debug(f'Valid CSRF Tokens for user {session.get("user")}\n'
                         f'{session["csrf_tokens"]}')

        
        return render_template('cards.html',
                            items=items,
                            next_page=results.next_page,
                            tokens=list(tokens.keys()))
    
    # If you're here and unauthenticated that's tough luck
    raise exceptions.Unauthorized

# OpenID Connect Sign in via OCI IAM Identity Domain Provider
@app.route('/login', methods=[HTTPMethod.GET])
def login():
    if not session.get('user'):
        uri = url_for('callback', _external=True)
        return oauth.ocidomain.authorize_redirect(uri)
    
    else:
        return redirect(url_for('home'))
    
@app.route('/callback', methods=[HTTPMethod.GET])
def callback():
    token = oauth.ocidomain.authorize_access_token()
    app.logger.debug(f'Returned OAuth Token: {token}')
    session['user'] = f'{token["userinfo"]["domain"]}/{token["userinfo"]["sub"]}'
    session['userinfo'] = token['userinfo']
    session['id_token'] = token['id_token']
    session['csrf_tokens'] = {}
    session['resource_type'] = 'all' # Support search filtering
    app.logger.debug(f'Decoded ID Token: {token["userinfo"]}')
    return redirect(url_for('home'))

# Logout behavior
@app.route('/logout', methods=[HTTPMethod.GET])
def logout():
    if session.get('user'):
        url = f'{idm_host}/oauth2/v1/userlogout?id_token_hint={session.get("id_token")}'
        url += f'&post_logout_redirect_uri={app_host}{url_for("home")}'
        session.clear()
        return redirect(url)
    
    return redirect(url_for('home'))

# Resource deletion logic
@app.route('/delete', methods=[HTTPMethod.DELETE])
def delete():
    app.logger.debug(f'Delete form data: {request.form}')
    app.logger.info(f'Recieved delete request for {request.form.get("title")} '
                     f'from {session.get("user")}')
    
    # Check session to see if CSRF token in user's pool
    if session.get('csrf_tokens').pop(request.form.get('csrf_token'), True):
        app.logger.info(f'CSRF Token violation from {session.get("user")} '
                        f'for {request.form.get("identifier")}')
        return render_template('button.html', status=HTTPStatus.BAD_REQUEST)
    
    # Validate user owns the resource
    if not search.validate_resource(session.get('user'),
                                    request.form.get('identifier')):
        return render_template('button.html', status=HTTPStatus.UNAUTHORIZED)

    result = deleter.terminate(request.form.copy())

    # Artificial delay for debugging
    if app.debug:
        sleep(2)

    return render_template('button.html', status=result)

# Resource update logic; Will be used for updating expiry tag
@app.route('/update', methods=[HTTPMethod.PATCH])
def update():
    # TODO
    return redirect(url_for('home'))

### Error Handlers ###

@app.errorhandler(exceptions.BadRequest)
def bad_request(e):
    return '<h1>400 Bad Request</h1><a href="/">Home</a>', 400

@app.errorhandler(exceptions.Unauthorized)
def unauthorized(e):
    return '<h1>401 Unauthorized</h1><a href="/">Home</a>', 401

@app.errorhandler(exceptions.Forbidden)
def forbidden(e):
    return '<h1>403 Forbidden</h1><a href="/">Home</a>', 403

@app.errorhandler(exceptions.NotFound)
def not_found(e):
    return '<h1>404 Not Found</h1><a href="/">Home</a>', 404

@app.errorhandler(exceptions.InternalServerError)
def server_error(e):
    return '<h1>500 Internal Server Error</h1><a href="/">Home</a>', 500
